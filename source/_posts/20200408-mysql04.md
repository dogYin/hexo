---
title: 查询优化
date: 2020-04-08 10:31:55
tags: mysql
categories: 'mysql'
---
    
　　在索引那节有讲单表查询使用索引的情况，请自行移步

<h1>连接查询优化</h1>

<h2>连接分析</h2>
    select * from table1 t1 xxx join table2 t2 on t1.id = t2.id where t1.id=1<br/>
    我们将上述语句中的t1表称为驱动表，t2表称为被驱动表（right join的情况下不成立）<br/>
    整个连接过程其实就是，先根据条件查询去驱动表中的记录（扇出值），然后拿着查询出来的记录（扇出值）一条条去被驱动表中查询记录，最后组装拼接<br/>
    嵌套循环连接:驱动表只访问一次，但被驱动表却可能被多次访问，访问次数取决于对驱动表执行单表查询后的结果集中的记录条数<br/>
    
连接类型|特点|注意事项
---|---|---
INNER|内连接，不区分驱动表和被驱动表|在内连接中ON子句和WHERE子句是等价的，只展示按条件过滤的两个表中共有的记录
LEFT|左外连接，from后面的是驱动表，join后面的是被驱动表 |驱动表中不为空，被驱动表为空时，会显示驱动表中记录，被驱动表字段也会显示，但值为null
RIGHT|右外连接，from后面的是被驱动表，join后面的是驱动表 |驱动表中不为空，被驱动表为空时，会显示驱动表中记录，被驱动表字段也会显示，但值为null

<h2>优化1</h2>
<h3>使用索引</h3>

    通过上面的连接分析，可将连接查询最终拆解为单表查询，这样我们就可以采用单标查询的优化方式（索引）
<h3>基于块的嵌套连接</h3>

    join buffer:执行连接查询前申请的一块固定大小的内存，先把若干条驱动表结果集中的记录装在这个join buffer中，<br/>
                然后开始扫描被驱动表，每一条被驱动表的记录一次性和join buffer中的多条驱动表记录做匹配，因为匹配<br/>
                的过程都是在内存中完成的，所以这样可以显著减少被驱动表的I/O代价

    join_buffer_size:该参数可以控制join buffer的大小，默认值为256kb
    
    注意：加入join buffer的列是我们查询中的列，并不是表中所有的列，所以我们查询的时候尽量不要以 select * 查询需要的字段。
<h2>优化2（基于成本的优化）</h2>

