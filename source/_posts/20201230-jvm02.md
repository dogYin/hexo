---
title: 垃圾回收随笔
date: 2020-12-30 16:12:09
tags:
    - java
    - jvm
categories:
    - jvm
top_img:
cover: https://cdn.jsdelivr.net/gh/dogYin/imgOSS/img/java.jpg
---
　　在[jvm内存空间](https://dogyin.wang/2020/09/17/20200917-jvm01/)这篇文章有详细的介绍有关java中内存的那些事，我们知道每一个被声明的变量以及创建出来的对象都需要一个容器承载，这个容器便是之前介绍的内存空间，既然每个微小的变量都需要地方存储，并且程序是运行在服务器上的，那么这个容器势必是有大小，既然有了边界限制那么就不可能无限制的往容器里装东西，为了我们能不断的往里面装新的东西，那么必须有应对措施，而我们能想到了通常有两种：1.增加容器的容量。2.清理无用垃圾。我们所说的垃圾回收机制可以从这两点触发至发散。

# 增加容器容量

　　怎么理解增加容器容量呢？如果单纯说增加容器容量其实是比较不严谨的说法，目前的各种业务场景都是基于微服务的，就是将服务按模块或者业务拆分为单独的块部署在各种小型机提供服务，如果一味的增加容量，小心机就会变成一个很累赘的大胖子，显然是不符合场景的，无论是当下还是以前这种情况都是不允许出现的。
　　但是，合理的调配堆大小也是不可忽略的；有种现象就是当我们服务刚刚启动是会发生频繁的GC，这是为什么呢？通过GC监控工具发现这种情况通常是由于Allocation Failure，这是由于 -Xmx -Xms两个参数设置大小不一，在初始阶段只申请大小为-Xms，当需要扩容时会触发垃圾收集，所以当发生不断扩容时就会有伴随着频繁的垃圾收集，那么为了避免频繁的垃圾收集是不是应该将两个参数都设置到一致；其实也分场景，如果是面向C端的服务，需要跟用户频繁的交互，无法忍受高频的停顿，但与之相反，对于一些富客户端应用两个参数的梯次配置倒是能节省一些空间。

# 清理无用垃圾

　　上面分析了增加容量的场景，但是增加容量显得比较有局限性；大头的动作应该放在垃圾清理这边。我们很了解生活场景中出现的垃圾，并会将其带离日常生活区域，同理要想知道怎么清理垃圾，要从以下个方面入手
1. 垃圾在哪里
2. 垃圾是什么
3. 怎么清理

## 1.垃圾在哪里

　　在分析垃圾在哪里之前，首先应该知道[jvm内存空间](https://dogyin.wang/2020/09/17/20200917-jvm01/)是如何布局的，这里假设了解了内存布局是什么样的，那么我们现在找找垃圾在哪里，便于分析我们先放张图
![](https://cdn.jsdelivr.net/gh/dogYin/imgOSS/img/jvm_grabe.PNG)
如上图所示，虚拟机栈和本地方法栈里面存储基本就是各种局部变量、动态链接和方法返回值等，而我们知道上述这些描述都是实例对象的引用指针，随着线程状态决定其生死所以垃圾回收我们不考虑这两块空间，其次就是程序计数器这块空间就是指向程序执行到哪里，也算是随着线程生死。
　　接下来就是元空间和堆空间，我们知道元空间存储的是类的描述信息以及类常量和运行时常量池，元空间中部分数据生命周期和类加载器相同，随着类加载的器的消亡也会产生垃圾，所以元空间也会有垃圾回收的动作发生，但通常都是伴随着Full GC，且元空间和堆是独立的使用对外内存，通常来说该区域垃圾回收应该较少。最后就是堆，程序所创建的实例都放在这里，这里是GC的主要目标，但是根据对象生命周期的特性，将该区域划分为两块空间，一块存放生命周期很短的那些对象，一块存放生命周期比较长的对象。
　　通过以上分析，得出结论**：垃圾在堆区和元空间，主要存放地还是堆区**


## 2.垃圾是什么

　　上面弄清楚了垃圾在哪里，紧接着我们探讨下究竟什么才是垃圾，jvm又是怎么区分垃圾的。
　　由于本文旨在大白话探讨垃圾回收，所以我们应该先通俗的理解什么是垃圾，百度对垃圾的解释是“**垃圾是失去使用价值、 无法利用的废弃物品，是物质循环的重要环节**”；同理，将这个概念拓展到jvm就是对运行程序无意义的实例以及类描述等信息，其实应该重点关注的就是这个无意义，抽象成物理模型在jvm中是如何做的呢？
　　专业描述垃圾：运行程序中没有任何指针指向的对象被称为垃圾；好，这里我们细化的找下垃圾

### 方法1

　　我们让当前运行程序中指向的对象维护一个计数器，当有被引用是计数器值加一，当引用失效时计数器值减一；在进行垃圾收集时直接将这些计数器为0的对象都归类为垃圾；这是个不错的方法，但是想想会有什么问题呢？如果A->B->C->B，当A指向BCB的这个引用断了之后，B->C->B还是互相引用；最终在垃圾归类时无法将其判断为垃圾，会造成比较严重的内存泄露；那既然这种发放有缺陷，有没有比较好点的方法；我们接着看方法2

### 方法2

　　首先找一组活跃的对象，然后往下找其引用的对象，层级遍历找到所有对象，这样会形成一个搜索链，当然这个搜索链有可能是多叉互连的，有点像数据结构中的有向图，当图中的某个节点找不到一条路径是走向活跃对象的，那么这个节点可以归类为垃圾，这就是鼎鼎大名的**可达性分析算法**。

> 小故事：
一个有名望的老宗师收了一帮弟子，他们之间就是师徒关系，然后弟子们开枝散叶又收了很多弟子，如此往复老宗师名满天下，但老宗师有个比较前卫的想法，一个徒弟可以不止有一个师傅，这样一来，当某个徒弟背叛了师门，那么只要他的弟子还有一个师傅没有背叛师门那么，这个弟子还是属于宗门，否则就不属于宗门了，对于这种不属于宗门的弟子会有专门的执法组去清理掉

在jvm中哪些对象可以作为这组活跃对象呢？
- 虚拟机栈中的引用对象（各个线程被调用的方法中的参数或者局部变量）
- JNI中的引用对象（本地方法中引用对象）
- 方法区中静态属性引用的对象
- 所有被同步锁（synchronized）持有的对象
- 方法区中常量引用的对象（String Tables）
- java虚拟机内部的引用，比如ClassLoader、各种异常类等常驻对象
- 分代引用时部分堆内对象

## 3.怎么清理

　　从上面一路走下来，终于到了清理阶段；日常生活中的垃圾清理有专门的清洁工负责，所以在jvm中应该也存在这样一个角色我们称之为垃圾回收器
　　在探讨垃圾在哪里那一小节中有提到，垃圾主要产生在堆中，那我们就重点已堆为例；根据对象的生命周期堆被分为了两大块，一块是存放朝生夕死对象的Eden区一块是存放存活时间较久的对象称为老年代；节虾类我们一块一块回收

### 新生代

　　新生代中的对象大部分都是朝生夕死的，而那些躲过垃圾回收的对象通过劲升或担保机制都去了老年代，针对朝生夕死这个特性，直接看jvm给出的回收方式

#### 回收算法

**标记-复制：**将整个内存区域分为两块，在垃圾回收时，将正在使用的一块中的存活对象复制到另一块中；然后整个清除使用中的那块内存
**优点：**实现过程简单，运行高效，保证内存空间连续性，不会产生内存碎片
**缺点：**需要两倍的内存空间，对象移动时引用地址也会发生变化
　　上述的算法描述的已经很明了，也给出了其优缺点，由于在对象移动过程中引用地址会发生改变，所以我们已经尽量的减少需要移动的对象，到了这里其实已经跟新生代对象的生命周期有了个良好的匹配，大部分对象朝生夕死也就是说，存活下来的对象会很少；且该种算法不会产生内存碎片，避免再维护一个空闲列表，后续给对象分配空间可以直接使用指针碰撞即可

#### 回收器

**Serial：**使用复制算法，串行回收，会发生STW，单核CPU下简单高效优于其他回收器（没有线程上下文切换）

**ParNew GC：**Serial的并行版本

**Parallel Scavenge：**高吞吐量回收器，适合后台运行不需要太多交互的场景


### 老年代

#### 回收算法

**标记-清除（Mark - Sweep）：**使用**根节点搜索算法**标记所有被引用的对象，遍历堆内存中所有对象，如果对象没有被标记，那么说明该对象应该被清除；其实是将垃圾对象所用地址放在一个空闲列表中，后续创建对象时，可从空闲列表中分配，垃圾对象还在原位置，并不会被清理，后续对象覆盖
**优点：**实现简单，清除速度快，清除过程是直接使用新对象覆盖即可，不需要清理内存块也不需要移动对象
**缺点：**效率低下；GC过程中需要停止整个应用，导致用户体验差；容易产生内存碎片，需要维护一个空闲列表；从标记到清除需要遍历两次

**标记-整理（Mark - Compact）：**使用**根节点搜索算法**标记所有被引用的对象，将所有标记过的对象放在内存的一端按顺序存放，然后将剩下的空间清理掉
**优点：**解决了标记清除算法中产生的内存碎片问题
**缺点：**效率上低于复制算法，移动对象时需要改变引用地址，移动过程中会发生STW
　　上述两个算法各有优劣，可以看出来标记-清除算法用在对响应速度要求较高的场景下，在面向C端的应用中，高停顿是不能被容忍的；相反的像某些富客户端应用对停顿时间并没有那么高的要求或者跟用户接触不是那么频繁，且对内存要求比较高，则可以使用标记整理算法

#### 回收器

**Serial Old：**使用标记整理算法，串行回收，会发生STW，作为CMS的后备方案

**Parallel Old：**使用标记整理算法，并行回收

**CMS：**使用标记清理算法，并发回收

![](https://cdn.jsdelivr.net/gh/dogYin/imgOSS/img/jvm_collector.PNG)

#### 聊聊搭配

　　上面简单的叙述了下垃圾回收算法和回收器，通常情况下都是成对出现的，在jdk1.8中默认的是搭配是Parallel Scavenge和Parallel Old，但是据我所知市面上面向C端业务的服务端，使用的基本都是低延迟的ParNew和CMS，其实CMS的并发回收还是有得一说

1. 初始标记：STW,仅仅只是标记处GC Roots能直接关联的对象，由于直接关联的对象很少，所以这个速度很快
2. 并发标记：从GC Roots直接关联对象开始，遍历整个对象图，该过程比较漫长，但是和用户线程并发执行
3. 重新标记：STW，因为并发标记过程中用户线程还在执行，所以需要重新标记下执行过程中关联的对象，这个过程比初始标记耗时久，但是比并发标记快（这里标记的是初始阶段怀疑是垃圾的对象，并不是新产生的垃圾对象）
4. 并发清理：清理掉标记过程中已死亡的对象，因为该过程不需要移动存活对象所以可以并发执行（如果使用标记压缩算法就无法达到并发清理，需要STW会将延迟升高）
5. 由于回收过程用户线程还在执行，所以需要提供足够大的内存，且不能在堆满了之后才开始清理，应该在达到一个阈值时就开始清理
6. 清理期间预留内存无法满足程序需要就会，报错“Concurrent Mode Failure”,这时候就会采取预备方案，临时使用Serial Old对老年代进行垃圾回收

上述流程就是CMS的回收过程，但是CMS也不是一个完美的回收器，不然jdk1.9中就不会移除它用G1回收器替代了，那我们探讨下为啥它不好呢，首先使用标记清除算法伴随着Full GC无法避免的会产生内存碎片，当有大量内存碎片产生时，大对象再次进入会触发Full GC，如果还是没有足够空间就会有高停顿的Serial Old回收器代替它回收，这个代价是昂贵的，而且并发标记阶段产生的垃圾没法回收；当了解了以上的不足，我们试着去改进它如果将它的清理换成整理好不好，显然不好，整理期间会STW,当移动的对象过多是，这个STW会很致命，那么现在需要考虑的就是怎么避免这个STW，即如何将移动后的对象引用重新指向，后续的Shenandoah和ZGC回收器都致力于解决这个问题，在这里就不继续的探讨下去了，有兴趣的可自行查阅